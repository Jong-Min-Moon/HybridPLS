)
)
){
return(FALSE)
warning("Different bases")
}else{
return(TRUE)
}
}
###########################################
)
# functional predictors is_same
is_same(functional_predictor_1, functional_predictor_1)
is_same(functional_predictor_1, functional_predictor_2)
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(Z = A.mat,
functional_predictor_1 = functional_predictor_1,
functional_predictor_2 = functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(Z = B.mat,
functional_predictor_1 = functional_predictor_2,
functional_predictor_2 = functional_predictor_1)
functional_predictor_2
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(Z = A.mat,
functional_predictor_1 = functional_predictor_1,
functional_predictor_2 = functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(Z = B.mat,
functional_predictor_1 = functional_predictor_2,
functional_predictor_2 = functional_predictor_1)
predictor_1@Z
predictor_2@Z
add(predictor_1, predictor_2)@Z #error occurs as expected
setMethod("add", "predictor_hybrid",
###########################################
function(input, other, alpha = 1) {
# can add only when the bases are the same
if (
!(
is_same(input@basis_1, other@basis_1) & is_same(input@basis_2, other@basis_2)
)
){
stop("Cannot add predictors with different bases")
}else{
# since the bases are the same, only update the coef of the bases
input@basis_1@coef <- add(input@basis_1@coef, other@basis_1@coef, alpha)
input@basis_2@coef <- add(input@basis_2@coef, other@basis_2@coef, alpha)
#update coef of the data
input@Z <- add(input@Z, other@Z, alpha)
return(input)
}
}
###########################################
)
add(predictor_1, predictor_2)@Z #error occurs as expected
setMethod("is_same_basis", "predictor_functional",
###########################################
function(input, other) {
if (
!(
prod(
(input@J == other@J) * (input@J_dotdot == other@J_dotdot)
)
)
){
return(FALSE)
warning("Different bases")
}else{
return(TRUE)
}
}
###########################################
)
# basis_hybridPLS object
setGeneric("is_same_basis", function(input, other)
standardGeneric("is_same_basis"))
setGeneric("add", function(input, other, alpha=1)
standardGeneric("add"))
setMethod("is_same_basis", "predictor_functional",
###########################################
function(input, other) {
if (
!(
prod(
(input@J == other@J) * (input@J_dotdot == other@J_dotdot)
)
)
){
return(FALSE)
warning("Different bases")
}else{
return(TRUE)
}
}
###########################################
)
# functional predictors is_same
is_same_basis(functional_predictor_1, functional_predictor_1)
is_same_basis(functional_predictor_1, functional_predictor_2)
add(predictor_1, predictor_2)@Z #error occurs as expected
setMethod("add", "predictor_hybrid",
###########################################
function(input, other, alpha = 1) {
# can add only when the bases are the same
if (
!(
is_same_basis(input@functional, other@basis_1) & is_same(input@basis_2, other@basis_2)
)
){
stop("Cannot add predictors with different bases")
}else{
# since the bases are the same, only update the coef of the bases
input@basis_1@coef <- add(input@basis_1@coef, other@basis_1@coef, alpha)
input@basis_2@coef <- add(input@basis_2@coef, other@basis_2@coef, alpha)
#update coef of the data
input@Z <- add(input@Z, other@Z, alpha)
return(input)
}
}
###########################################
)
add(predictor_1, predictor_2)@Z #error occurs as expected
# n: number of observations
# p: number of scalar predictors
# M: number of basis functions for each functional predictors
setClass(
"predictor_hybrid",
representation(
# scalar predictors:
## n x p matrix of real-valued covariates.
## each row represents an observed finite-dimensional vector.
Z = "matrix",
# functional predictors
## basis expansion representation
## number of predictors can be arbitrary
functional_predictors = "list",
n_functional_predictors = "numeric"
))
create_hybrid_predictors_kidney <- function(Z, functional_predictor_1, functional_predictor_2){
if(
!(
class(functional_predictor_1)[1] == "predictor_functional"
) & (
class(functional_predictor_2)[1] == "predictor_functional"
)
){
stop("Inputs should be functional predictor objects")
}else{
predictor_object <- new("predictor_hybrid",
Z = Z,
functional_predictors = list(
functional_predictor_1,
functional_predictor_2
),
n_functional_predictors = 2
)
return(predictor_object)
}
}
# n: number of observations
# p: number of scalar predictors
# M: number of basis functions for each functional predictors
setClass(
"predictor_hybrid",
representation(
# scalar predictors:
## n x p matrix of real-valued covariates.
## each row represents an observed finite-dimensional vector.
Z = "matrix",
# functional predictors
## basis expansion representation
## number of predictors can be arbitrary
predictor_functional_list = "list",
n_predictor_functional = "numeric"
))
create_hybrid_predictors_kidney <- function(Z, predictor_functional_1, predictor_functional_2){
if(
!(
class(predictor_functional_1)[1] == "predictor_functional"
) & (
class(predictor_functional_2)[1] == "predictor_functional"
)
){
stop("Inputs should be functional predictor objects")
}else{
predictor_object <- new("predictor_hybrid",
Z = Z,
predictor_functional_list = list(
predictor_functional_1,
predictor_functional_2
),
n_predictor_functional = 2
)
return(predictor_object)
}
}
a = list[1,2]
a
a = list(1,2)
a
a[1]
a[[1]]
setMethod("is_same_basis", "predictor_hybrid",
###########################################
function(input, other){
if(
input@n_predictor_functional != other@n_predictor_functional
){
stop("Number of the functional predictors must be the same")
}
is_different_elem = 0
for (i in 1:input@n_predictor_functional){
is_different_elem = is_different_elem * (
prod(
(input@predictor_functional_list[[i]]@J        == other@predictor_functional_list[[i]]@J) *
(input@predictor_functional_list[[i]]@J_half   == other@predictor_functional_list[[i]]@J_half) *
(input@predictor_functional_list[[i]]@J_dotdot == other@predictor_functional_list[[i]]@J_dotdot)
)
)
}
if(is_different_elem){
return(FALSE)
warning("Different bases")
}else{
return(TRUE)
}
}
###########################################
)
# create two functional predictors
functional_predictor_1 <- create_predictor_functional(coef = A.mat, J = B.mat %*% t(B.mat), J_dotdot = A.mat %*% t(A.mat))
functional_predictor_2 <- create_predictor_functional(coef = A.mat + 1, J = B.mat %*% t(B.mat) + 1, J_dotdot = A.mat %*% t(A.mat) + 1)
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(Z = A.mat,
functional_predictor_1 = functional_predictor_1,
functional_predictor_2 = functional_predictor_2)
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_1)
is_same_basis(predictor_1, predictor_2)
!1
setMethod("is_same_basis", "predictor_hybrid",
###########################################
function(input, other){
if(
input@n_predictor_functional != other@n_predictor_functional
){
stop("Number of the functional predictors must be the same")
}
is_different_elem = 1
for (i in 1:input@n_predictor_functional){
is_different_elem = is_different_elem * !(
prod(
(input@predictor_functional_list[[i]]@J        == other@predictor_functional_list[[i]]@J) *
(input@predictor_functional_list[[i]]@J_half   == other@predictor_functional_list[[i]]@J_half) *
(input@predictor_functional_list[[i]]@J_dotdot == other@predictor_functional_list[[i]]@J_dotdot)
)
)
}
if(is_different_elem){
return(FALSE)
warning("Different bases")
}else{
return(TRUE)
}
}
###########################################
)
# create two functional predictors
functional_predictor_1 <- create_predictor_functional(coef = A.mat, J = B.mat %*% t(B.mat), J_dotdot = A.mat %*% t(A.mat))
functional_predictor_2 <- create_predictor_functional(coef = A.mat + 1, J = B.mat %*% t(B.mat) + 1, J_dotdot = A.mat %*% t(A.mat) + 1)
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_1)
is_same_basis(predictor_1, predictor_2)
setMethod("is_same_basis", "predictor_hybrid",
###########################################
function(input, other){
if(
input@n_predictor_functional != other@n_predictor_functional
){
stop("Number of the functional predictors must be the same")
}
is_all_elem_same = 1
for (i in 1:input@n_predictor_functional){
is_all_elem_same = is_all_elem_same * (
prod(
(input@predictor_functional_list[[i]]@J        == other@predictor_functional_list[[i]]@J) *
(input@predictor_functional_list[[i]]@J_half   == other@predictor_functional_list[[i]]@J_half) *
(input@predictor_functional_list[[i]]@J_dotdot == other@predictor_functional_list[[i]]@J_dotdot)
)
)
}
if(is_all_elem_same){
return(TRUE)
}else{
return(FALSE)
warning("Different bases")
}
}
###########################################
)
# create two functional predictors
functional_predictor_1 <- create_predictor_functional(coef = A.mat, J = B.mat %*% t(B.mat), J_dotdot = A.mat %*% t(A.mat))
functional_predictor_2 <- create_predictor_functional(coef = A.mat + 1, J = B.mat %*% t(B.mat) + 1, J_dotdot = A.mat %*% t(A.mat) + 1)
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_1)
is_same_basis(predictor_1, predictor_2)
predictor_1@Z
predictor_2@Z
add(predictor_1, predictor_2)@Z #error occurs as expected
#this should work
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_2)
is_same_basis(predictor_1, predictor_2)
add(predictor_1, predictor_2)@Z #error occurs as expected
setMethod("add", "predictor_hybrid",
###########################################
function(input, other, alpha = 1) {
# can add only when the bases are the same
if(!(is_same_basis(input, other))){
stop("Cannot add predictors with different bases")
}else{
# since the bases are the same, only update the coef of the bases
for (i in 1:input@n_predictor_functional){
input@predictor_functional_list[[i]]@coef <- add(
input@predictor_functional_list[[i]]@coef,
other@predictor_functional_list[[i]]@coef,
alpha
)
}
#update coef of the data
input@Z <- add(input@Z, other@Z, alpha)
return(input)
}
}
###########################################
)
add(predictor_1, predictor_2)@Z #error occurs as expected
setMethod("add", "matrix",
###########################################
function(input, other, alpha = 1) {
# dimension check
if(
prod( dim(input) != dim(other) ) > 0
){
stop("Cannot add")
# operation
}else{
return(input + alpha * other)
}
}
###########################################
)
add(predictor_1, predictor_2)@Z #error occurs as expected
A.mat + B.mat #verify
add(predictor_1, predictor_2)@Z #error occurs as expected
# create hybrid predictors with different bases
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_1)
is_same_basis(predictor_1, predictor_2)
predictor_1@Z
predictor_2@Z
add(predictor_1, predictor_2)@Z #error occurs as expected
#this should work
predictor_1 <- create_hybrid_predictors_kidney(A.mat, functional_predictor_1, functional_predictor_2)
predictor_2 <- create_hybrid_predictors_kidney(B.mat, functional_predictor_1, functional_predictor_2)
is_same_basis(predictor_1, predictor_2)
predictor_1@Z
predictor_2@Z
add(predictor_1, predictor_2)@Z
A.mat + B.mat #verify
predictor_1@basis_1
predictor_1@predictor_functional_list[[1]]
predictor_2@predictor_functional_list[[1]]
predictor_1@predictor_functional_list[[1]]
predictor_2@predictor_functional_list[[1]]
add(predictor_1, predictor_2)@predictor_functional_list[[1]]
alpha = 3
-alpha
setMethod("sub", "predictor_hybrid",
#######################################
function(input, other, alpha = 1){
return(add(input, other, -alpha))
}
#######################################
)
setGeneric("sub", function(input, other, alpha=1)
standardGeneric("sub"))
setGeneric("sub", function(input, other, alpha=1)
standardGeneric("sub"))
setGeneric("sub", function(input, other, alpha=1)
standardGeneric("sub"))
setMethod("sub", "predictor_hybrid",
#######################################
function(input, other, alpha = 1){
return(add(input, other, -alpha))
}
#######################################
)
# basis_hybridPLS object
setGeneric("is_same_basis", function(input, other)
standardGeneric("is_same_basis"))
setGeneric("add", function(input, other, alpha=1)
standardGeneric("add"))
setGeneric("subtr", function(input, other, alpha=1)
standardGeneric("subtr"))
setMethod("subtr", "predictor_hybrid",
#######################################
function(input, other, alpha = 1){
return(add(input, other, -alpha))
}
#######################################
)
predictor_1@predictor_functional_list[[1]]
predictor_2@predictor_functional_list[[1]]
sub(predictor_1, predictor_2)@predictor_functional_list[[1]]
setMethod("subtr", "predictor_hybrid",
#######################################
function(input, other, alpha = 1){
return(add(input, other, -alpha))
}
#######################################
)
sub(predictor_1, predictor_2)@predictor_functional_list[[1]]
setMethod("add", "predictor_hybrid",
###########################################
function(input, other, alpha = 1) {
# can add only when the bases are the same
if(!(is_same_basis(input, other))){
stop("Cannot add predictors with different bases")
}else{
# since the bases are the same, only update the coef of the bases
for (i in 1:input@n_predictor_functional){
input@predictor_functional_list[[i]]@coef <- add(
input@predictor_functional_list[[i]]@coef,
other@predictor_functional_list[[i]]@coef,
alpha
)
}
#update coef of the data
input@Z <- add(input@Z, other@Z, alpha)
return(input)
}
}
###########################################
)
sub(predictor_1, predictor_2)@predictor_functional_list[[1]]
setMethod("is_same_basis", "predictor_hybrid",
###########################################
function(input, other){
if(
input@n_predictor_functional != other@n_predictor_functional
){
stop("Number of the functional predictors must be the same")
}
is_all_elem_same = 1
for (i in 1:input@n_predictor_functional){
is_all_elem_same = is_all_elem_same * (
prod(
(input@predictor_functional_list[[i]]@J        == other@predictor_functional_list[[i]]@J) *
(input@predictor_functional_list[[i]]@J_half   == other@predictor_functional_list[[i]]@J_half) *
(input@predictor_functional_list[[i]]@J_dotdot == other@predictor_functional_list[[i]]@J_dotdot)
)
)
}
if(is_all_elem_same){
return(TRUE)
}else{
return(FALSE)
warning("Different bases")
}
}
###########################################
)
sub(predictor_1, predictor_2)@predictor_functional_list[[1]]
setMethod("add", "matrix",
###########################################
function(input, other, alpha = 1) {
# dimension check
if(
prod( dim(input) != dim(other) ) > 0
){
stop("Cannot add")
# operation
}else{
return(input + alpha * other)
}
}
###########################################
)
sub(predictor_1, predictor_2)@predictor_functional_list[[1]]
bdiag(3)
library(Matrix)
library(fda)
library(pracma)
install.packages("pracma")
install.packages("jpeg")
library(pracma)
library(jpeg)
library(MASS)
install.packages("fda")
library(fda)
sigma <- list()
sigma
# initialize the storage
sigma <- delta <- list()
sigma <- delta <- list()
delta
sigma
# initialize the storage
sigma <- delta <- xi <- rho <- list()
